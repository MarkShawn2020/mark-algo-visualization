# Development Rationality

## 算法可视化的 Component、Layout 复用逻辑

对绝大多数算法的可视化，基本构成主要包括：
1. 测例，以及基于测例的修改、重置。
2. 控制台，主要包括输出信息、下一步、重启，以及额外的一些控制，比如历史回溯。
3. 展示台，主要使用css布局或echarts、d3等框架展示算法执行过程中的数据结构切片。
4. 算法标识、介绍、笔记、用户反馈，等其他非功能性需求。

基于以上的考虑，目前算法可视化的V1版本设计理念如下。

### 算法可视化 V0.0.1 实现逻辑
一、UI呈现方面
分左右两栏，左栏从上到下分成三个子模块，依次为展示模块、控制模块、测例模块，右栏从上到下分成两个模块，依次为笔记输入模块、笔记实时渲染（markdown）模块。

在展示模块中，将其左上角设置为该算法的面包屑导航标识，清晰明确。此外，在右上角包含一些可配置的按钮，以供用户操作，比如："算法介绍"，将暂定设计成一个弹窗的形式。

对于笔记栏，将使用`flex`布局，仅对PC、Pad等大屏浏览器启用双栏布局，对于移动端将使用单栏布局，紧挨在测例模块之后，并关闭实时渲染模块。

二、组件设计方面
对于一个算法可视化组件来说，主要的依赖有三个：一个是算法标识及其他相关信息，它主要内嵌于展示模块；一个是默认的初始测例，它将联动展示模块和测例模块；一个是算法的执行与输出过程，它将联动展示模块和控制模块。

在此基础之上，可抽象出算法可视化组件的通用设计，具体来说，这个组件的构成包括：
1. 算法信息 
   - 算法的id
   - 算法的网页路径
   - 算法的面包屑导航
   - 算法的图文介绍
2. 测例数据
3. 算法运行部分
    - 初始化
    - 下一步
    - 重置
    - 其他控制
   
基于此，可以定义一个算法可视化的组件接口如下：
```typescript
export interface DAlgoInfo {
  id?: string;
  path?: string;
  nav: Array<string>;
  intro?: string;
}

export interface DAlgoCtrl {
  init: any;
  next: any;
  stop: any;
  extra: any[]
}

export interface DAlgoCase {
  content: string;
  modify: any;
  reset: any;
  save?: any;
}

export interface DAlgoLog {
  content: Array<string>;
  info: any;
  warning?: any;
  error?: any;
  clear: any
}

export interface DAlgoVisualization {
  info: DAlgoInfo;
  tCase: DAlgoCase;
  ctrl: DAlgoCtrl;
  log: DAlgoLog;
  children: any
}
```
1. 接口`DAlgoInfo`的设计
   
由于`id`一般可以通过其他字段经由`hash`得到，所以可以暂时不用考虑，而基于`nextjs`框架提供的文件路由机制，`path`也无需特意声明，`intro`部分可以后续更新，所以暂时只需要考虑前端展示部分的`nav`字段。

2. 接口`DAlgoCase`的设计
   
测例是重要的，测例在整个算法可视化组件中扮演着唯一输入流的顶层角色。

首先我们需要为每个算法提供一个默认测例，比如对于`KMP`算法，我们可以提供一个`abbca`的初始化测例，基于这个测例，可便利用户直接进入算法的演示环节。

但我们也需要提供用户修改测例的功能，修改过程中，展示模块的测例数据源应以修改后的测例为准，并从头开始执行。也可以使用修改+保存的组合形式，这样可以提高执行效率。

与修改操作相对应地，我们还应当提供复原测例的功能。

3. 接口`DAlgoCtrl`的设计

程序执行逻辑部分，往往是最难写也是最容易出错的，更不用说我们需要为上百个算法都要一一实现其内部的逻辑与外部的呈现。

但无论什么算法，最基本的三个接口分别是初始化、下一步和停止。

为什么是停止？而非重新运行？事实上，停止的转态标识是重要且不可分割的，比如对于排序算法，需要记录一个停止状态以防用户并不知道排序已经完成。但重新运行却可以基于停止状态，结合初始化实现，这是可分割的。所以我们无需考虑重新运行的接口。

3. 接口`DAlgoVisualization`的设计 
   
`children`是子组件的占位符，由于不同算法的可视化所呈现的样貌、实现的形式均或有不同，因此必须抽离出来，单独实现。




